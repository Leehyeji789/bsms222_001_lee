---
title: '**Chapter 3. Programming basics**'
output:
  html_document:
    df_print: paged
---

<br/>

We teach R because it greatly facilitates data analysis, the main topic of this book. By coding in R, we can efficiently perform exploratory data analysis, build data analysis pipelines, and prepare data visualization to communicate results. However, R is not just a data analysis environment but a programming language. Advanced R programmers can develop complex packages and even improve R itself, but we do not cover advanced programming in this book. Nonetheless, in this section, we introduce three key programming concepts: conditional expressions, for-loops, and functions. These are not just key building blocks for advanced programming, but are sometimes useful during data analysis. We also note that there are several functions that are widely used to program in R but that we will not cover in this book. These include `split`, `cut`, `do.call`, and `Reduce`, as well as the **data.table** package. These are worth learning if you plan to become an expert R programmer.

<br/>

# 3.1 Conditional expressions

<br/>

Conditional expressions are one of the basic features of programming. They are used for what is called *flow control*. The most common conditional expression is the if-else statement. In R, we can actually perform quite a bit of data analysis without conditionals. However, they do come up occasionally, and you will need them once you start writing your own functions and packages.

Here is a very simple example showing the general structure of an if-else statement. The basic idea is to print the reciprocal of `a` unless `a` is 0:
```{r}
a <- 0

if(a!=0){
  print(1/a)
} else{
  print("No reciprocal for0.")
}
```
Let's look at one more example using the US murders data frame:
```{r}
library(dslabs)
data(murders)
murder_rate <- murders$total / murders$population*100000
```

Here is a very simple example that tells us which states, if any, have a murder rate lower than 0.5 per 100,000. The `if` statement protects us from the case in which no state satisfies the condition.
```{r}
ind <- which.min(murder_rate)

if(murder_rate[ind] < 0.5){
  print(murders$state[ind])
} else{
  print("No state has murder rate that low")
}
```

If we try it again with a rate of 0.25, we get a different answer:
```{r}
if(murder_rate[ind] < 0.25){
  print(muders$state[ind])
} else{
    print("No state has a murder rate that low.")
}
```
A related function that is very useful is `ifelse`. This function takes three arguments: a logical and two possible answers. If the logical is `TRUE`, the value in the second argument is returned and if `FALSE`, the value in the third argument is returned. Here is an example:
```{r}
a <- 0
ifelse(a > 0, 1/a, NA)
```
The function is particularly useful because it works on vectors. It examines each entry of the logical vector and returns elements from the vector provided in the second argument, if the entry is `TRUE`, or elements form teh vector provided in the third argument, if the entry is `FALSE`.
